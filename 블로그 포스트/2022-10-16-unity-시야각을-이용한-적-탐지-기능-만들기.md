---
layout: post
title: "[Unity] ì‹œì•¼ê°ì„ ì´ìš©í•œ ì  íƒì§€ ê¸°ëŠ¥ ë§Œë“¤ê¸°"
date: 2022-10-16 00:33 +0900
categories: [Tips,Tips-Unity]
tags: [tips]     # TAG names should always be lowercase
use_math: true
---

# ì‹œì•¼ê°ì„ ì´ìš©í•œ ì  íƒì§€ ê¸°ëŠ¥ ë§Œë“¤ê¸°

```
ê²Œì„ì—ì„œ ì‹œì•¼ê°ì€ ìì£¼ ì“°ì´ëŠ” ë‚´ìš©ì´ê³  ê·¸ë˜ì„œ ê´€ë ¨ ìë£Œë„ ë§ì´ ìˆìŠµë‹ˆë‹¤.
í•˜ì§€ë§Œ ìë£Œë§ˆë‹¤ ë§Œë“œëŠ” ë²•ì´ ë‹¤ ë‹¤ë¥´ë‹¤ë³´ë‹ˆ ì§ì ‘ ë§Œë“¤ì–´ë³´ë©´ì„œ ì •ë¦¬ë¥¼ í•´ë³´ì•˜ìŠµë‹ˆë‹¤.

ê°œì¸ ê³µë¶€ì„ìœ¼ë¡œ í‹€ë¦° ì ì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ì  ì°¸ê³  ë¶€íƒë“œë¦¬ë©°
ëŒ“ê¸€ì€ í° ë„ì›€ì´ ë˜ë‹ˆ ì–¸ì œë‚˜ í™˜ì˜ì…ë‹ˆë‹¤ ğŸ˜€
```

# ì„œë¡ 

Aê°€ í”Œë ˆì´ì–´ì´ê³ , AëŠ” ì„¸íƒ€ ê°ë„ë¥¼ ê°€ì§„ ì‹œì•¼ê°ì´ ìˆìœ¼ë©°
ì´ ë•Œ ì (ë¹¨ê°„ ì )ì´ ì‹œì•¼ì— ë“¤ì–´ì˜¤ëŠ”ì§€ ì•„ë‹Œì§€ë¥¼ í™•ì¸í•˜ëŠ” ê±¸ ë§Œë“¤ ì˜ˆì •ì´ë‹¤.

![](/assets/img/posts/2022-10-16_UNITY_FOV_16.png)  

Gizmosë¥¼ ì¨ì„œ ì‹œì•¼ê°ì„ ë§Œë“¤ê¹Œ í–ˆëŠ”ë° ê·¸ê²ƒë³´ë‹¤ ê°œë°œ ì¤‘ì—ë„ ë³´ì´ëŠ” ê²Œ í¸í•  ê²ƒ ê°™ì•„ Editor ê¸°ëŠ¥ì¸

`private void OnSceneGUI()` ë¥¼ ì‚¬ìš©í–ˆë‹¤.

ì‹¤ì œ ê²Œì„ì— ë°”ë¡œ ì ìš©í•´ ë³¼ ìˆ˜ ìˆë‹¤ ë³´ë‹¤ëŠ” ê¸°ë³¸ì ì¸ ê¸°ëŠ¥ êµ¬í˜„ì— ì´ˆì ì„ ë§ì¶”ì—ˆë‹¤.

(ì •ë¦¬í•˜ëŠ” ê¸€ì¸ë° ì‹¤ì œ ê²Œì„ì— ì ìš©í•  ìˆ˜ ìˆê²Œ í•˜ë©´ ë„ˆë¬´ ê¸¸ê³  ì§€ì €ë¶„í•˜ë‹ˆê¹Œ..!)

# ë³¸ë¡ 

ì¼ë‹¨ êµ¬í˜„ì„ ìœ„í•´ ì˜¤ë¸Œì íŠ¸ë¥¼ ì„¸íŒ…í•´ë‘ì

Playerë¥¼ ë‹´ë‹¹í•  Cube ê°ì²´ì™€ Enemyë¥¼ ë‹´ë‹¹í•  Sphere ê°ì²´ë¥¼ ìƒì„±í•´ì£¼ê³ 

PlayerëŠ” Vector3.zeroì— EnemyëŠ” Playerì˜ ì „ë°©ì— ì¡´ì¬í•  ìˆ˜ ìˆë„ë¡ ì„¸íŒ…í•œë‹¤.

![](/assets/img/posts/2022-10-16_UNITY_FOV_1.png)  

ì´ ë•Œ íë¸Œì˜ ì „ë°©ì´ ì–´ë”˜ì§€ í™•ì‹¤íˆ ì•Œì•„ì•¼ êµ¬í˜„ì„ ì •í™•í•˜ê²Œ í•  ìˆ˜ ìˆë‹¤.

ê·¸ëŸ¬ë¯€ë¡œ ì „ë°©ì´ ì–´ë”˜ì§€ í™•ì¸í•  ìˆ˜ ìˆëŠ” ì½”ë“œë¥¼ ë¨¼ì € êµ¬í˜„í•´ë³´ì.

## 1. ê°ì²´ ì „ë°©ì€ ì–´ë””..?

ë¨¼ì € `DetectRangeTest.cs` ìŠ¤í¬ë¦½íŠ¸ë¥¼ ìƒì„±í•˜ê³  Player ê°ì²´ì— ë„£ì–´ì£¼ì

ê·¸ë¦¬ê³  Editor í´ë”ë¥¼ ìƒì„±í•œ í›„ DetectRangeEditor.cs ë¥¼ ìƒì„± ê·¸ ë‹¤ìŒ ì•„ë˜ì™€ ê°™ì´ ì½”ë“œë¥¼  ë„£ì–´ì¤€ë‹¤.

```csharp
using UnityEditor;

[CustomEditor(typeof(DetectRangeTest))]
public class DetectRangeEditor : Editor
{
    private void OnSceneGUI()
    {
		// targetë¥¼ í†µí•´ í•´ë‹¹ ì—ë””í„°ê°€ ì°¸ì¡°í•˜ëŠ” classë¥¼ ê°€ì ¸ì˜¨ë‹¤.
		// ì—¬ê¸°ì„œëŠ” DetectRangeTest classì— í•´ë‹¹í•œë‹¤.
        DetectRangeTest player = (DetectRangeTest)target;

        Handles.color = Color.cyan;
				
		// ìœ ë‹ˆí‹° ë‚´ x,y,z ì¶• ê¸°ì¦ˆëª¨ì™€ ê²¹ì¹˜ê²Œ ë¨ìœ¼ë¡œ ë¼ì¸ ë‘ê»˜ë¥¼ 5f ì •ë„ ì£¼ì—ˆë‹¤.
        Handles.DrawLine(player.transform.position, player.transform.forward * 2f, 5f);
    }
}
```

ì ìš© í›„ Player ê°ì²´ë¥¼ í´ë¦­í•˜ë©´ ì•„ë˜ì™€ ê°™ì´ cyan ìƒ‰ì˜ ì„ ì´ ìƒê¸°ëŠ” ê±¸ ë³¼ ìˆ˜ ìˆë‹¤.

![](/assets/img/posts/2022-10-16_UNITY_FOV_2.png)
> ì„ ì„ í†µí•´ Zì¶•ì´ ì „ë°©ì„ì„ ì•Œ ìˆ˜ ìˆë‹¤.

ì´ì œ ì „ë°©ì„ ì•Œì•˜ìœ¼ë‹ˆ ì‹œì•¼ê°ì„ ë§Œë“¤ì–´ë³´ì!

## 2. ì‹œì•¼ ë²”ìœ„ êµ¬í˜„

í‘œí˜„ì´ ì¢€ ì´ìƒí•œë° Playerë¥¼ ì›ì ìœ¼ë¡œ í•˜ë©´ì„œ ì‹œì•¼ ê±°ë¦¬ê°€ ë°˜ì§€ë¦„ì¸ ì›ì„ ê·¸ë¦¬ëŠ” ê±°ë‹¤.

ì´ê±¸ ë§Œë“œëŠ” ì´ìœ ëŠ” Playerì˜ ì‹œì•¼ ê±°ë¦¬ë¥¼ ì§ê´€ì ìœ¼ë¡œ ì²´í¬í•˜ê¸° ìœ„í•´ì„œ ì´ë‹¤.

ê·¸ë¦¼ìœ¼ë¡œ ë§Œë“¤ì–´ë³´ë©´ ì•„ë˜ì™€ ê°™ë‹¤.

![](/assets/img/posts/2022-10-16_UNITY_FOV_3.png)  
>ë°˜ì§€ë¦„ rì€ Playerì˜ ì‹œì•¼ ê±°ë¦¬ê°€ ëœë‹¤.

ì´ì œ ì € ì› ì•ˆì— ë“¤ì–´ì˜¤ë©´ playerì˜ ì‹œì•¼ì— ë“¤ì–´ì˜¤ê²Œ ë˜ëŠ” ê²ƒì´ë‹¤.

ì´ì œ ì½”ë“œë¡œ ë§Œë“¤ì–´ë³´ì.

ì½”ë“œë¡œëŠ” `Handles.DrawWireArc` ë¥¼ í†µí•´ ë§Œë“¤ ê²ƒì´ë‹¤.

```csharp
private void OnSceneGUI()
{
    DetectRangeTest player = (DetectRangeTest)target;

    Handles.color = Color.cyan;
    Handles.DrawLine(player.transform.position, player.transform.forward * 2f, 5f);

	// ì›ì€ ì»¬ëŸ¬ë¥¼ í°ìƒ‰ìœ¼ë¡œ í•´ì£¼ì—ˆë‹¤.
    Handles.color = Color.white;
    Handles.DrawWireArc(player.transform.position, player.transform.up, Vector3.forward, 360f, player._radius);
}
```

ì—¬ê¸°ì„œ from íŒŒë¼ë¯¸í„°ê°€ ì´í•´ê°€ ì˜ ì•ˆë˜ì—ˆëŠ”ë°

ê³µì‹ ë¬¸ì„œ ì˜ˆì œë¥¼ ë³´ë©´ 

```csharp
var center = position;
var start = Vector3.left;
var normal = Vector3.forward;
var radius = 3 - i * 0.3f;
var angle = 40 + 30 * i;
Handles.DrawWireArc(center, normal, start, angle, radius, i);
```

from ì„ startë¼ê³  í‘œí˜„í•˜ê³  ìˆë‹¤. ì¦‰, Arc(í˜¸)ì˜ ì‹œì‘ ë¶€ë¶„ì´ë¼ ë³´ë©´ ë  ê²ƒ ê°™ë‹¤.

> normalì€ ë²•ì„  ë²¡í„°ë¥¼ ì˜ë¯¸í•œë‹¤.
> 

ê·¸ëŸ¬ë¯€ë¡œ, ì•„ë˜ ì½”ë“œëŠ” ì´ë ‡ê²Œ í•´ì„í•  ìˆ˜ ìˆë‹¤.

```csharp
/** 
* í˜¸ì˜ ì¤‘ì‹¬ì€ Player ìœ„ì¹˜ì´ê³  
* player.transform.upì„ ë²•ì„  ë²¡í„°ë¡œ ê°€ì¡Œìœ¼ë©°
* playerì˜ ë¡œì»¬ ë²¡í„° (0,0,1) ê¸°ì¤€ìœ¼ë¡œ 
* _radius(DetectRangeTest classì˜ ë³€ìˆ˜) ë°˜ì§€ë¦„ì„ ê°€ì§„ ì›ì„ ê·¸ë¦¬ëŠ”ë°
* Arc(í˜¸)ëŠ” ì›ì˜ 360ë„ ë¶€ë¶„ì´ë‹¤.
*/
Handles.DrawWireArc(player.transform.position, player.transform.up, Vector3.forward, 360f, player._radius);
```

## 2-1. ì‹œì•¼ê° ë§Œë“¤ê¸°

```
ìœ„ì—ì„œ ë§í–ˆë“¯ì´, ê¸°ëŠ¥ êµ¬í˜„ì— ì´ˆì ì„ ë§ì¶”ì—ˆê¸° ë•Œë¬¸ì—
Playerê°€ Vector3.zeroì— ê³ ì •ë˜ì–´ ìˆë‹¤ê³  ê°€ì •í•˜ê³  êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

ê·¸ë˜ì„œ ì•„ë˜ ì½”ë“œ ì˜ˆì‹œë“¤ì€
Player ìœ„ì¹˜ì— ìƒê´€ ì—†ì´ ì‹œì•¼ê°ì€ Vector3.zeroë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê³ ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
```

![](%/assets/img/posts/2022-10-16_UNITY_FOV_4.png)

ì‹œì•¼ê°ì„ ìœ„ì˜ ì´ˆë¡ìƒ‰ ì„ ì²˜ëŸ¼ ë§Œë“¤ ê²ƒì´ë‹¤.

ì €ë ‡ê²Œ ì´ˆë¡ìƒ‰ ì„ ì„ ë§Œë“¤ê¸° ìœ„í•´ì„œëŠ” **ì‹œì•¼ê°ì— ë”°ë¥¸ ë²¡í„° ê°’**ì´ í•„ìš”í•œë° ì´ë¥¼ êµ¬í˜„í•´ ë³¼ ê²ƒì´ë‹¤.

## 2-2. ê°ë„ì— ë”°ë¥¸ ë²¡í„° ê°’ ì°¾ê¸°

êµ¬í˜„ì„ ìœ„í•´ ìš°ë¦¬ëŠ” ì‚¼ê° í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ê²ƒì´ë‹¤.

í‰ì†Œ ìš°ë¦¬ê°€ ì•„ëŠ” ê³µë¶€í–ˆë˜ ê²ƒì²˜ëŸ¼ ì¢Œí‘œê³„ë¥¼ ê·¸ë ¤ë³´ë©´

ì•„ë˜ì™€ ê°™ì´ X, Z ì¶•ì„ ê°€ì§„ ì¢Œí‘œê³„ê°€ ìˆê³  ë¹—ë³€ ê¸¸ì´ê°€ rì¸ ì§ê°ì‚¼ê°í˜•ì´ ìˆì„ ë•Œ 

ë…¸ë€ìƒ‰ ì ì˜ ì¢Œí‘œ ê°’ì€ (rcos(a),rsin(a)) ì¼ ê²ƒì´ë‹¤.

![](/assets/img/posts/2022-10-16_UNITY_FOV_5.png)

í•˜ì§€ë§Œ ìš°ë¦¬ëŠ” Zì¶•ì´ ì „ë°©ì´ê¸° ë•Œë¬¸ì— ì•„ë˜ì™€ ê°™ì´ ë´ì•¼ í•œë‹¤.

ì´ë ‡ê²Œ ë˜ë©´ ë…¸ë€ìƒ‰ ì ì˜ ì¢Œí‘œ ê°’ì€ (rsin(a),rcos(a))ê°€ ë  ê²ƒì´ë‹¤.

![](/assets/img/posts/2022-10-16_UNITY_FOV_6.png)

í•´ë‹¹ ë‚´ìš©ì„ ì½”ë“œë¡œ ì‘ì„±í•´ë³´ë©´ ì•„ë˜ì™€ ê°™ë‹¤.

> ë°˜ì§€ë¦„ rì„ ì •ê·œí™”í•´ì„œ r = 1 ë¡œ ë§Œë“¤ì–´ ì¤€ ìƒíƒœì´ë‹¤.
   -> ë‹¨ìœ„ ë²¡í„°ë¥¼ ì˜ë¯¸í•œë‹¤.
> 

```csharp
// zì¶•ì´ ì „ë°©ì´ ìƒíƒœì—ì„œ angle ë§Œí¼ íšŒì „í•œ Vector3 ê°’ ë°˜í™˜
Vector3 AngleToDir(float angle)
{
    // UnityEngine.Mathf ì˜ Sin, Cos ì— ë“¤ì–´ê°€ëŠ” íŒŒë¼ë¯¸í„° ê°’ì€ ë¼ë””ì•ˆì´ë‹¤.
    // ê·¸ëŸ¬ë¯€ë¡œ, ë¼ë””ì•ˆìœ¼ë¡œ ë°”ê¿”ì¤˜ì•¼ í•œë‹¤. 
    float rad = angle * Mathf.Deg2Rad;
    return new Vector3(Mathf.Sin(rad), 0, Mathf.Cos(rad));
}
```

## 2-3. ì‹œì•¼ê° ë§Œë“¤ê¸°

ì´ì œ ì‹œì•¼ê°ì„ ë§Œë“¤ì–´ ë³´ì! ìš°ë¦¬ëŠ” ì•„ë˜ì™€ ê°™ì´ ì‹œì•¼ê°ì„ ë§Œë“¤ ì˜ˆì •ì´ë‹¤.

![](/assets/img/posts/2022-10-16_UNITY_FOV_7.png)

ìì„¸íˆ ë³´ë©´ ì£¼ì˜í•  ì ì´ í•˜ë‚˜ ìˆëŠ”ë° ìš°ë¦¬ê°€ ì›í•˜ëŠ” **ì‹œì•¼ê°ì€ a + a ì´ë‹¤.**

ì¦‰, **ì‹œì•¼ê°ì´ 90ë„ë¼ê³  í•˜ë©´ a ëŠ” 45ë„ê°€ ë˜ì–´ì•¼ í•˜ëŠ” ê²ƒì´ë‹¤.**

ì´ ì ì„ ìœ ì˜í•˜ë©´ì„œ ì½”ë“œë¥¼ ì‘ì„±í•´ë³´ì

```csharp
Handles.color = Color.green;

// ì‹œì•¼ê°ì´ 90ë„ì¼ ë•Œ, 45ë„
Vector3 rightDir = AngleToDir(player._angle * 0.5f);

// ì‹œì•¼ê°ì´ 90ë„ì¼ ë•Œ, -45ë„
Vector3 leftDir = AngleToDir(player._angle * -1 * 0.5f);

Handles.DrawLine(Vector3.zero, rightDir * player._radius);
Handles.DrawLine(Vector3.zero, leftDir * player._radius);
```

## 2-4. ì  íƒì§€í•˜ê¸°

í”Œë ˆì´ì–´ì˜ ì‹œì•¼ê°ì€ ì „ë¶€ ë§Œë“¤ì—ˆë‹¤. ì´ì œ ì‹œì•¼ê°ì— ì ì´ ë“¤ì–´ì™”ì„ ë•Œ ì ì„ íƒì§€í•˜ëŠ” ê¸°ëŠ¥ì„ ë§Œë“¤ì–´ë³´ì

í”Œë ˆì´ì–´ ì‹œì•¼ì— ì ì´ ë“¤ì–´ì™”ë‹¤ëŠ” ê±¸ ì–´ë–»ê²Œ ì•Œ ìˆ˜ ìˆì„ê¹Œ??

ì ì´ ì‹œì•¼ì— ë“¤ì–´ì™”ì„ ë•ŒëŠ” ì•„ë˜ ì´ë¯¸ì§€ì™€ ê°™ì„ ê²ƒì´ë‹¤.

![](/assets/img/posts/2022-10-16_UNITY_FOV_8.png)  
> ì‚¬ê°í˜•ì´ Player ê³  ë¹¨ê°„ ì›ì´ Enemy ì´ë‹¤.

ì´ë¯¸ì§€ë¥¼ í†µí•´ ìš°ë¦¬ëŠ” ì‹œì•¼ì— ì ì´ ë“¤ì–´ì™”ë‹¤ëŠ” ê±¸ ì•Œê¸° ìœ„í•´ì„œ 2ê°€ì§€ ê¸°ëŠ¥ì´ í•„ìš”í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.

1. í”Œë ˆì´ì–´ì™€ ì  ê°„ì˜ ê±°ë¦¬
2. í”Œë ˆì´ì–´ì™€ ì  ê°„ì˜ ê°ë„

1ë²ˆë¶€í„° í™•ì¸í•´ë³´ì.

## 2-4-1. í”Œë ˆì´ì–´ì™€ ì  ê°„ì˜ ê±°ë¦¬

ì´ê±´ ì•„ì£¼ ê°„ë‹¨í•˜ë‹¤.

ì™œëƒí•˜ë©´ ì´ë¯¸ ìœ ë‹ˆí‹°ì—ì„œ ë‘ ê°ì²´ ê°„ì˜ ê±°ë¦¬ê°€ ì–¼ë§ˆì¸ì§€ êµ¬í•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ë¥¼ ì§€ì›í•´ì£¼ê³  ìˆê¸° ë•Œë¬¸ì´ë‹¤.

ì§€ì›í•´ì£¼ê³  ìˆëŠ” ê²ƒë“¤ì€ 3ê°€ì§€ê°€ ìˆëŠ”ë° ì•„ë˜ì™€ ê°™ë‹¤.

- Vector3.Distance(Vector3 a, Vector3 b) â†’ ë‘  ë²¡í„° ê°„ ê±°ë¦¬ ë°˜í™˜
- Vector3.Magnitude(Vector3 vector) â†’ ë²¡í„°ì˜ ê¸¸ì´ ë°˜í™˜
- Vector3.SqrMagnitude(Vector3 vector) â†’ ë²¡í„° ê¸¸ì´ì˜ ì œê³±ì„ ë°˜í™˜

ì—¬ê¸°ì„œ ì—°ì‚°ì˜ íš¨ìœ¨ì„±ì„ ìœ„í•´ `Vector3.SqrMagnitude(Vector3 vector)` ë¥¼ ì‚¬ìš©í•  ê²ƒì´ë‹¤.

> (x,y,z) ë²¡í„°ì˜ í¬ê¸°ëŠ”  $\sqrt{x^2 + y^2 + z^2}$  ì´ë‹¤.
ì—¬ê¸°ì„œ ë£¨íŠ¸ëŠ” ì—°ì‚° ì†ë„ê°€ ì¢‹ì§€ ì•Šê¸° ë•Œë¬¸ì— ì œê³±í•œ ê°’ì¸ ${x^2 + y^2 + z^2}$ ë¡œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ë‹¤.
> 

ì´ì œ ì½”ë“œë¡œ êµ¬í˜„í•´ë³´ì.

```csharp
Handles.color = Color.red;

// ì—°ì‚°ì„ ë¹ ë¥´ê²Œ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì œê³±ëœ ê°’ì„ êµ¬í•œë‹¤.
float sqrDistance = Vector3.SqrMagnitude(player._enemy.transform.position - player.transform.position);

if(sqrDistance < player._radius * player._radius)
{
     Handles.DrawLine(player.transform.position, player._enemy.position, 5f);
}
```

ê²°ê³¼ëŠ” ì•„ë˜ì™€ ê°™ì´ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

![](/assets/img/posts/2022-10-16_UNITY_FOV_9.png)  
> íƒì§€ ê±°ë¦¬ì— Enemyê°€ ë“¤ì–´ì™”ì„ ë•Œ

![](/assets/img/posts/2022-10-16_UNITY_FOV_10.png)  
> íƒì§€ ê±°ë¦¬ì— Enemyê°€ ì—†ì„ ë•Œ

## 2-4-2. í”Œë ˆì´ì–´ì™€ ì  ê°„ì˜ ê°ë„

ì´ì œ ê°ë„ë¥¼ í™•ì¸í•´ì•¼ í•œë‹¤.

ì™œëƒí•˜ë©´ ê°ë„ê°€ ì—†ìœ¼ë©´ ì‹œì•¼ê° ì•ˆì— ì—†ì–´ë„ íƒì§€ê°€ ë˜ê¸° ë•Œë¬¸ì´ë‹¤

![](/assets/img/posts/2022-10-16_UNITY_FOV_11.png)  
> ì‹œì•¼ê° ì™¸ë¶€ì— ìˆëŠ”ë° íƒì§€ê°€ ë˜ê³  ìˆë‹¤.

ì—¬ê¸°ì„œ ìš°ë¦¬ëŠ” 2ê°€ì§€ ë°©ë²•ì„ í•  ìˆ˜ ìˆë‹¤.

ì•„ë˜ì™€ ê°™ì€ ì§ê°ì‚¼ê°í˜•ì´ ìˆì„ ë•Œ

![](/assets/img/posts/2022-10-16_UNITY_FOV_12.png)

- ${tan(\theta) = \frac{a}{b}}$ ë¥¼ ì´ìš©í•œ ${\theta = \arctan(\frac{a}{b})}$
- ${cos(\theta) = \frac{b}{c}}$ ë¥¼ ì´ìš©í•œ ${\theta = \arccos(\frac{b}{c})}$

ìš°ë¦° ì—¬ê¸°ì„œ ${\theta = \arctan(\frac{a}{b})}$ ë¥¼ ì‚¬ìš©í•  ê²ƒì´ë‹¤.

```csharp
float GetAngle(Vector3 origin, Vector3 target)
{
    Vector3 direction = target.normalized - origin.normalized;

	/**
     * zê°€ ì „ë°©ì´ê¸° ë•Œë¬¸ì—
     * y íŒŒë¼ë¯¸í„° : x
     * x íŒŒë¼ë¯¸í„° : z
     * ê°’ì´ ë“¤ì–´ê°„ë‹¤.
     */
    return Mathf.Atan2(direction.x, direction.z) * Mathf.Rad2Deg;
}
```

ì´ì œ ê±°ë¦¬ì™€ ê°ë„ ì½”ë“œë¥¼ í•©ì¹˜ë©´ ì•„ë˜ì™€ ê°™ë‹¤.

```csharp
if(sqrDistance < player._radius * player._radius &&
  GetAngle(player.transform.position, player._enemy.position) < player._angle * 0.5f)
{
      Handles.DrawLine(player.transform.position, player._enemy.position, 5f);
}
```

ê·¸ ê²°ê³¼ ì‹œì•¼ ë²”ìœ„ ë‚´ì— ë“¤ì–´ì™”ì„ ë•Œ ì ì„ íƒì§€í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.

![](/assets/img/posts/2022-10-16_UNITY_FOV_13.png)

![](/assets/img/posts/2022-10-16_UNITY_FOV_14.png)

![](/assets/img/posts/2022-10-16_UNITY_FOV_15.png)

# ì „ì²´ ì½”ë“œ
ì „ì²´ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

```csharp
using UnityEngine;

public class DetectRangeTest : MonoBehaviour
{
    public int _radius;
    public Transform _enemy;
    public int _angle;
}
```

```csharp
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(DetectRangeTest))]
public class DetectRangeEditor : Editor
{
    private void OnSceneGUI()
    {
        // targetë¥¼ í†µí•´ í•´ë‹¹ ì—ë””í„°ê°€ ì°¸ì¡°í•˜ëŠ” classë¥¼ ê°€ì ¸ì˜¨ë‹¤.
        // ì—¬ê¸°ì„œëŠ” DetectRangeTest classì— í•´ë‹¹í•œë‹¤.
        DetectRangeTest player = (DetectRangeTest)target;

        Handles.color = Color.cyan;
        Handles.DrawLine(player.transform.position, player.transform.forward * 2f, 5f);

        // ì›ì€ ì»¬ëŸ¬ë¥¼ í°ìƒ‰ìœ¼ë¡œ í•´ì£¼ì—ˆë‹¤.
        Handles.color = Color.white;
        Handles.DrawWireArc(player.transform.position, player.transform.up, Vector3.forward, 360f, player._radius);

        Handles.color = Color.green;

        // ì‹œì•¼ê°ì´ 90ë„ì¼ ë•Œ, 45ë„
        Vector3 rightDir = AngleToDir(player._angle * 0.5f);

        // ì‹œì•¼ê°ì´ 90ë„ì¼ ë•Œ, -45ë„
        Vector3 leftDir = AngleToDir(player._angle * -1 * 0.5f);

        Handles.DrawLine(Vector3.zero, rightDir * player._radius);
        Handles.DrawLine(Vector3.zero, leftDir * player._radius);

        Handles.color = Color.red;

        // ì—°ì‚°ì„ ë¹ ë¥´ê²Œ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì œê³±ëœ ê°’ì„ êµ¬í•œë‹¤.
        float sqrDistance = Vector3.SqrMagnitude(player._enemy.transform.position - player.transform.position);

        if(sqrDistance < player._radius * player._radius &&
            GetAngle(player.transform.position, player._enemy.position) < player._angle * 0.5f)
        {
            Handles.DrawLine(player.transform.position, player._enemy.position, 5f);
        }
    }

    Vector3 AngleToDir(float angle)
    {
        // UnityEngine.Mathf ì˜ Sin, Cos ì— ë“¤ì–´ê°€ëŠ” íŒŒë¼ë¯¸í„° ê°’ì€ ë¼ë””ì•ˆì´ë‹¤.
        // ê·¸ëŸ¬ë¯€ë¡œ, ë¼ë””ì•ˆìœ¼ë¡œ ë°”ê¿”ì¤˜ì•¼ í•œë‹¤. 
        float rad = angle * Mathf.Deg2Rad;
        return new Vector3(Mathf.Sin(rad), 0, Mathf.Cos(rad));
    }

    float GetAngle(Vector3 origin, Vector3 target)
    {
        Vector3 direction = target.normalized - origin.normalized;

        /**
         * zê°€ ì „ë°©ì´ê¸° ë•Œë¬¸ì—
         * y íŒŒë¼ë¯¸í„° : x
         * x íŒŒë¼ë¯¸í„° : z
         * ê°’ì´ ë“¤ì–´ê°„ë‹¤.
         */
        return Mathf.Atan2(direction.x, direction.z) * Mathf.Rad2Deg;
    }
}
```